<!DOCTYPE html>
<html lang="en">


<head>
    <meta charset="UTF-8">
    <title>Примерка колец by Au7umn</title>
    <link rel="stylesheet" href="css/modal.css">
</head>


<body>
    <!-- <div class="modal closed" data-z-index="1000" data-name="ring-modal1">
        <div class="overlay"></div>
        <div class="content">
            <div data-function="close-modal" data-modal-name="ring-modal1">Закрыть</div>
            <div>Lorem, ipsum dolor sit amet consectetur adipisicing elit. Minima, nam accusamus. Quisquam quis dolor quasi aliquid perspiciatis. Ullam atque cum a placeat sapiente aperiam excepturi reprehenderit sit illo maiores temporibus dolorum, illum amet in ex, odit voluptate cupiditate odio autem deleniti! Ipsam quidem quis unde natus quia? Totam doloremque ratione deleniti a pariatur adipisci consectetur obcaecati. Dolorum praesentium quasi perferendis vitae placeat officia, ad exercitationem maxime accusamus voluptatum itaque fugiat optio aliquid facilis illum hic voluptates repellat dolorem delectus mollitia voluptas dignissimos! Possimus dolores voluptas magni magnam, mollitia corporis nesciunt ipsum porro pariatur laudantium natus atque doloribus fugiat ipsa id.</div>
            <div data-function="open-modal" data-modal-name="try-on-modal">Try-on</div>

            Но вообще сюда нужно закидывать верстку от фуункции getRingModalHtml, включая кнопки закрытия и открытия примерки
        </div>
    </div> -->

    <div class="modal closed" data-z-index="1000" data-name="ring-modal1">
        <div class="overlay"></div>
        <div class="content">
            <div data-function="close-modal" data-modal-name="ring-modal1">Закрыть</div>
            <div>Lorem, ipsum dolor sit amet consectetur adipisicing elit. Minima, nam accusamus. Quisquam quis dolor quasi aliquid perspiciatis. Ullam atque cum a placeat sapiente aperiam excepturi reprehenderit sit illo maiores temporibus dolorum, illum amet in ex, odit voluptate cupiditate odio autem deleniti! Ipsam quidem quis unde natus quia? Totam doloremque ratione deleniti a pariatur adipisci consectetur obcaecati. Dolorum praesentium quasi perferendis vitae placeat officia, ad exercitationem maxime accusamus voluptatum itaque fugiat optio aliquid facilis illum hic voluptates repellat dolorem delectus mollitia voluptas dignissimos! Possimus dolores voluptas magni magnam, mollitia corporis nesciunt ipsum porro pariatur laudantium natus atque doloribus fugiat ipsa id.</div>
            <div data-function="open-modal" data-modal-name="try-on-modal" onclick="enableWebcam()">Try-on</div>

            Но вообще сюда нужно закидывать верстку от фуункции getRingModalHtml, включая кнопки закрытия и открытия примерки
        </div>
    </div>

    <div class="modal closed" data-z-index="1001" data-name="try-on-modal">
        <div class="overlay"></div>
        <div class="content">
            <section id="demos" class="">
                <div data-function="close-modal" data-modal-name="try-on-modal">Закрыть</div>
                <div id="liveView" class="videoView">
                    <button id="webcamButton" class="mdc-button mdc-button--raised">
                        <span class="mdc-button__ripple"></span>
                        <span class="mdc-button__label">Примерить</span>
                    </button>
        
                    <div id="try_on" style="display: none;">
                        <div style="position: relative;">
                            <video id="webcam" style="position: relative" autoplay="" playsinline=""></video>
                            <canvas class="output_canvas" id="output_canvas" style="position: absolute; left: 0px; top: 0px;"></canvas>
                            <div id="overlay"></div>
        
                            <label for="ringSizeTextBox">Текущая размерность кольца относительно 3D-модели:</label><br>
                            <input type="text" id="ringSizeTextBox" value="" readonly>
                        </div>
        
                        <div>
                            <input type="checkbox" id="toggleLandmarks" checked>
                            <label for="toggleLandmarks">Рисовать распознаваемые узлы</label>
                            <input type="checkbox" id="toggleConnectors" checked>
                            <label for="toggleConnectors">Рисовать связи между узлами</label>
                            <input type="checkbox" id="toggleModelMovement">
                            <label for="toggleModelMovement">Заморозить движение кольца по Y координатам</label>
                            <div>
                                <label for="ringSizeSlider">Изменить размер кольца:</label><br>
                                <input type="range" id="ringSizeSlider" min="0" max="100" value="50">
                            </div>
                            <div>
                                <label for="changeYoffset">Изменить положение кольца по Y координатам:</label><br>
                                <input type="range" id="changeYoffset" min="0" max="10" value="5" style="-webkit-appearance: slider-vertical; writing-mode: bt-lr; height: 75px;">
                            </div>
                        </div>
                    </div>
                </div>
            </section>
        </div>
    </div>

    <div class="ring-card" data-function="open-modal" data-modal-name="ring-modal1" data-ring-id="1">КОЛЬЦО ЗАЕБАТОО 1</div>
    <div class="ring-card" data-function="open-modal" data-modal-name="ring-modal1" data-ring-id="2">КОЛЬЦО ЗАЕБАТОО 2</div>
    <div class="ring-card" data-function="open-modal" data-modal-name="ring-modal1" data-ring-id="3">КОЛЬЦО ЗАЕБАТОО 3</div>

    <script src="js/modal.js"></script>





    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.163.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.163.0/examples/jsm/"
            }
        }
    </script>

    <link href="https://unpkg.com/material-components-web@latest/dist/material-components-web.min.css" rel="stylesheet">
    <script src="https://unpkg.com/material-components-web@latest/dist/material-components-web.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script id="rendered-js" type="module">
        import { HandLandmarker, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0";
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import * as THREE from 'three';

        const demosSection = document.getElementById("demos");
        const ringSizeTextBox = document.getElementById("ringSizeTextBox");
        const toggleConnectorsCheckbox = document.getElementById("toggleConnectors");
        const toggleLandmarksCheckbox = document.getElementById("toggleLandmarks");
        const toggleModelMovementCheckbox = document.getElementById("toggleModelMovement");
        const ringSizeSlider = document.getElementById("ringSizeSlider");

        let currentSelectedRingInfo = undefined;
        let handLandmarker = undefined;
        let runningMode = "VIDEO";
        let enableWebcamButton;
        let webcamRunning = false;
        let lastVideoTime = -1;
        let results = undefined; // Объявляем переменную results
        let modelAdded = false;
        let model = new THREE.Object3D();
        let position14 = new Object;
        let position13 = new Object;
        let positionRing = new Object;

        console.log(currentSelectedRingInfo);

        // Before we can use HandLandmarker class we must wait for it to finish loading. Machine Learning models can be large and take a moment to get everything needed to run.
        const createHandLandmarker = async () => {
            const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm");
            handLandmarker = await HandLandmarker.createFromOptions(vision, {
                baseOptions: {
                    modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
                    delegate: "GPU"
                },
                runningMode: runningMode,
                numHands: 2
            });
            demosSection.classList.remove("invisible");
        };
        
        createHandLandmarker();

        // Continuously grab image from webcam stream and detect it.
        const video = document.getElementById("webcam");
        const canvasElement = document.getElementById("output_canvas");
        const canvasCtx = canvasElement.getContext("2d");

        const camera = new THREE.PerspectiveCamera(20, canvasElement.width / canvasElement.height, 0.1, 100);
        camera.position.z = 2;

        // Check if webcam access is supported.
        //const hasGetUserMedia = () => { var _a; return !!((_a = navigator.mediaDevices) === null || _a === void 0 ? void 0 : _a.getUserMedia); };

        // If webcam supported, add event listener to button for when user wants to activate it.
        // if (hasGetUserMedia()) {
        //     enableWebcamButton = document.getElementById("webcamButton");
        //     enableWebcamButton.addEventListener("click",  );
        // } else {
        //     console.warn("getUserMedia() is not supported by your browser");
        // }

        // // Toggle webcam and processing
        // function toggleWebcam() {
        //     if (webcamRunning) {
        //         disableWebcam();
        //     } else {
        //         enableWebcam();
        //     }
        // }

        function enableWebcam() {
            if (webcamRunning) { 
                return;
            }
            // Start webcam and processing
            const constraints = {
                    video: {
                        facingMode: 'environment' // Use back camera
                    }
                };
                navigator.mediaDevices.getUserMedia(constraints).then((stream) => {
                    video.srcObject = stream;
                    video.addEventListener("loadeddata", predictWebcam);
                    document.getElementById("try_on").style.display = "block";
                    enableWebcamButton.innerText = "Завершить";
                    webcamRunning = true;
                }).catch((error) => {
                    console.error("Error accessing webcam:", error);
                });
        }

        function disableWebcam () {
            if (!webcamRunning) { 
                return;
            }
            // Stop webcam and processing
            video.srcObject.getTracks().forEach(track => track.stop()); // Остановка всех треков видео
                video.srcObject = null;
                video.removeEventListener("loadeddata", predictWebcam);
                enableWebcamButton.innerText = "Примерить";
                webcamRunning = false;
                document.getElementById("try_on").style.display = "none";
        }

        // Detect landmarks in webcam video
        async function predictWebcam() {
            // Проверяем, что handLandmarker создан
            if (!handLandmarker || !webcamRunning) {
                canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
                model.visible = false;
                console.log("HandLandmarker is not loaded or webcam is not running.");
                return;
            }

            canvasElement.style.width = video.videoWidth;
            canvasElement.style.height = video.videoHeight;
            canvasElement.width = video.videoWidth;
            canvasElement.height = video.videoHeight;

            const currentTime = video.currentTime;
            if (currentTime !== lastVideoTime) {
                lastVideoTime = currentTime;
                results = handLandmarker.detectForVideo(video, performance.now());
                //console.log('results: ', results);  
            }

            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);

            // Отрисовываем лэндмарки, создаем модель, позиционируем ее относительно лэндмарки
            if (results && results.landmarks) {
                for (const landmarks of results.landmarks) {
                    if (toggleConnectorsCheckbox.checked) {
                        drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {
                            color: "#FFFFFF",
                            lineWidth: 5
                        });
                    }
                    if (toggleLandmarksCheckbox.checked) {
                        drawLandmarks(canvasCtx, landmarks, {
                            color: "#00BFFF",
                            lineWidth: 2
                        });
                    }
                }
                if (!modelAdded && results.landmarks.length !== 0) {
                    addModel();
                    modelAdded = true;
                } else if (modelAdded && results.landmarks.length !== 0) {
                    //// Приведение к общей системе координат
                    //// Для 0 14
                    position14.x = (results.landmarks[0][14].x) * 2 - 1; // Преобразование x в диапазон [-1, 1]
                    position14.y = (1 - results.landmarks[0][14].y) * 2 - 1; // Преобразование y в диапазон [-1, 1]
                    position14.z = -1; // Без Z позиция не копируется
                    //// Для 0 13
                    position13.x = (results.landmarks[0][13].x) * 2 - 1; // Преобразование x в диапазон [-1, 1]
                    position13.y = (1 - results.landmarks[0][13].y) * 2 - 1; // Преобразование y в диапазон [-1, 1]
                    //// Для кольца
                    positionRing.x = position14.x; 
                    if (toggleModelMovementCheckbox.checked) positionRing.y = model.position.y;
                    else positionRing.y = position14.y;
                    positionRing.z = position14.z;
                    ////

                    let sliderValue = parseInt(ringSizeSlider.value) * 2 / 100;
                    let newScale = results.landmarks[0][0].z * 70000 * sliderValue;
                    //let newScale = results.landmarks[0][0].z * 50000;
                    ringSizeTextBox.value = newScale;
                    model.scale.set(newScale, newScale, newScale);

                    model.position.copy(positionRing);
                    model.visible = true; // Показываем модель

                    // Вычисляем угол между горизонтальной прямой и прямой, образованной точками results.landmarks[0][13] и results.landmarks[0][14]
                    let deltaY = position13.y - position14.y;
                    let deltaX = position13.x - position14.x;
                    let angle = Math.atan2(deltaY, deltaX);

                    // Преобразуем радианы в градусы и вращаем модель по оси Z
                    let degrees = angle * (180 / Math.PI);
                    //console.log(degrees);
                    model.rotation.z = degrees / 30;
                } else if (modelAdded && results.landmarks.length == 0) {
                    model.visible = false; // Скрываем модель
                }
            }

            canvasCtx.restore();

            // Call this function again to keep predicting when the browser is ready.
            if (webcamRunning) {
                window.requestAnimationFrame(predictWebcam);
            }
        }

        // Функция для добавления модели на сцену
        function addModel() {
            const scene = new THREE.Scene();
            const renderer = new THREE.WebGLRenderer({ alpha: true });
            renderer.setSize(canvasElement.width, canvasElement.height);
            renderer.domElement.style.position = "absolute";
            renderer.domElement.style.top = "0";
            renderer.domElement.style.left = "0";
            renderer.physicallyCorrectLights = true;
            renderer.outputEncoding = THREE.sRGBEncoding;

            document.getElementById("overlay").appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xFFFFFF);
            ambientLight.intensity = 2;
            scene.add(ambientLight);

            const loader = new GLTFLoader();
            loader.load(
                'app/models/ring_black_and_red.glb',
                function(gltf) {
                    model = gltf.scene;
                    model.scale.set(0.01, 0.01, 0.01);
                    scene.add(model);
                },
                undefined,
                function(error) {
                    console.error('An error happened', error);
                }
            );

            function animate() {
                requestAnimationFrame(animate);
                renderer.render(scene, camera);
            }
            animate();
        }
    
        const initCardsEvents = () => {
            Array.from(document.getElementsByClassName('ring-card')).forEach((ringCardElement) => {
                const modalName = ringCardElement.dataset.modalName;
                const modalContent = document.querySelector(`.modal[data-name="${modalName}"] .content`);
                
                const ringId = parseInt(ringCardElement.getAttribute('data-ring-id'));
                ringCardElement.onclick = () => {
                    const html = getRingModalHtml(modalName, ringId);
                    modalContent.innerHTML = html;
                    ///найти в innerhtml кнопку tryon и присвоить ему onclick enableWebcam()
                    console.log(modalContent.innerHTML);
                    modalsManager.init();
                }
            })
        }
        
        initCardsEvents();

        const getRingModalHtml = (modalName, ringId) => {
            const ringData = ringsRepository[ringId];
            return `<div class="ring-modal">
                <div class="picture">
                    <img src="${ringData.imageSrc}"></img>
                </div>
                <div class="title">
                    ${ringData.name}
                </div>
                <div class="description">
                    ${ringData.decscription}
                </div>
                <div data-function="open-modal" data-modal-name="try-on-modal" onclick="enableWebcam()">Try-on</div>
                <div data-function="close-modal" data-modal-name="${modalName}">Закрыть</div>
            </div>`
        }

        const ringsRepository = {
            1: {
                name: 'ring_black_and_red 1',
                imageSrc: 'google.com',
                modelPath: 'app/models/ring_black_and_red.glb',
                decscription: 'asdasd'
            },
            2: {
                name: 'simple_ring 2',
                imageSrc: 'google.com',
                modelSrc: 'app/models/simple_ring.glb',
                decscription: 'asdasd'
            },
            3: {
                name: 'asdasd 3',
                imageSrc: 'google.com',
                modelSrc: '',
                decscription: 'asdasd'
            },
        }
    </script>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm/vision_wasm_internal.js" crossorigin="anonymous"></script>

</body>

</html>